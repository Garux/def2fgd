
#include "entwriter.h"
#include "rapidxml_ext.h"
using namespace rapidxml;
#include "string_nocase.h"
#include "entdictionary.h"
#include <set>

#ifndef DEF2FGD_VERSION
#define DEF2FGD_VERSION "unknown (was built without version)"
#endif

void writeEnt(std::ostream& stream, const std::vector<Entity>& entities){
    const KeyTypes keyTypes = readEntDictionary();
    std::set<NcString> unknownKeys;

    xml_document<> doc;
    {
        xml_node<> *decl = doc.allocate_node(node_declaration);
        doc.append_node(decl);
        decl->append_attribute(doc.allocate_attribute("version", "1.0"));
    }
    {
        doc.append_node(doc.allocate_node(node_comment, nullptr, "//generated by def2fgd " DEF2FGD_VERSION ));
    }

    xml_node<> *rootNode = doc.allocate_node(node_element, "classes");
    doc.append_node(rootNode);

    for ( const Entity& entity : entities )
    {
        xml_node<> *entNode = doc.allocate_node(node_element, entity.solid? "group" : "point",
            doc.allocate_string( ( '\n' + entity.description ).c_str() ) );
        rootNode->append_node(entNode);

        entNode->append_attribute( doc.allocate_attribute( "name", entity.name.c_str() ) );
        entNode->append_attribute( doc.allocate_attribute( "color",
            doc.allocate_string( ( std::to_string( entity.color[0] ) + " "
                                 + std::to_string( entity.color[1] ) + " "
                                 + std::to_string( entity.color[2] ) ).c_str() ) ) );

        if (!entity.solid) {
            entNode->append_attribute( doc.allocate_attribute( "box",
                doc.allocate_string( ( std::to_string( entity.box[0] ) + " "
                                     + std::to_string( entity.box[1] ) + " "
                                     + std::to_string( entity.box[2] ) + " "
                                     + std::to_string( entity.box[3] ) + " "
                                     + std::to_string( entity.box[4] ) + " "
                                     + std::to_string( entity.box[5] ) ).c_str() ) ) );

            if (!entity.model.empty()) {
                entNode->append_attribute( doc.allocate_attribute( "model", entity.model.c_str() ) );
            }
        }

        for ( const Key& key : entity.keys )
        {
            const char *keyType = "string";
            {
                const auto it = keyTypes.find( key.name );
                if( it != keyTypes.end() ){
                    if( entity.solid && it->second == "angle" )
                        keyType = "direction"; // angle specialization for solid classes
                    else
                        keyType = it->second.c_str();
                }
                else{
                    unknownKeys.emplace( key.name );
                }
            }
            xml_node<> *keyNode = doc.allocate_node(node_element, keyType, key.description.c_str() );
            entNode->append_node( keyNode );

            keyNode->append_attribute( doc.allocate_attribute( "key", key.name.c_str() ) );
            {
                NcString name = key.name;
                if (!name.empty())
                    name[0] = toupper(name[0]);
                keyNode->append_attribute( doc.allocate_attribute( "name", doc.allocate_string( name.c_str() ) ) );
            }
        }

        for (size_t j=0; j<Entity::SpawnFlagNum; ++j)
        {
            if( !entity.spawnflags[j].empty()
             && entity.spawnflags[j] != "x"
             && entity.spawnflags[j].compare( 0, 6, "unused" ) != 0 ){
                xml_node<> *flagNode = doc.allocate_node(node_element, "flag", entity.flagsdescriptions[j].c_str() );
                entNode->append_node( flagNode );
                flagNode->append_attribute( doc.allocate_attribute( "key", entity.spawnflags[j].c_str() ) );
                {
                    NcString name( entity.spawnflags[j] );
                    for( auto& c : name )
                        c = tolower( c );
                    name[0] = toupper( name[0] );
                    flagNode->append_attribute( doc.allocate_attribute( "name", doc.allocate_string( name.c_str() ) ) );
                }
                flagNode->append_attribute( doc.allocate_attribute( "bit", doc.allocate_string( std::to_string( j ).c_str() ) ) );
            }
        }
    }

    rapidxml::print( stream, doc, print_no_indenting );

    for( const auto& unknown : unknownKeys )
        fprintf(stderr, translate("Unknown key: \"%s\"\n").c_str(), unknown.c_str() );
}